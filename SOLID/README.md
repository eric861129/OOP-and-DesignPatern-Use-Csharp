# SOLID 與最小知識原則

SOLID 是物件導向設計的五個基本原則，旨在讓軟體設計更易於理解、靈活和維護。額外補充的**最小知識原則**也同樣重要。遵守這些原則可以幫助開發者建立高內聚、低耦合的系統。

SOLID 五大原則加上一個重要朋友，總共六個原則，分別是：

1.  **S - 單一職責原則** (Single Responsibility Principle, SRP)
2.  **O - 開放封閉原則** (Open-Closed Principle, OCP)
3.  **L - 里氏替換原則** (Liskov Substitution Principle, LSP)
4.  **I - 介面隔離原則** (Interface Segregation Principle, ISP)
5.  **D - 依賴反轉原則** (Dependency Inversion Principle, DIP)
6.  **迪米特法則 / 最小知識原則** (Law of Demeter / Least Knowledge Principle, LKP)

---

## S－單一職責原則 (SRP)

**一個類別應只有一個引起它變化的原因，也就是說，它只應該負責一項職責。**

當一個類別負責了太多職責，就像一筆流水帳，所有邏輯都混在一起。例如，一個 `AddOrder()` 方法，從處理訂單邏輯、寫入資料庫到寄送通知信，全部包辦。這樣的程式碼會變得非常冗長，且難以維護。只要其中任何一個環節的需求變更（例如通知方式從 Email 改成簡訊），都必須修改這個龐大的類別，影響範圍難以界定。

**遵守 SRP 的好處：**
* **提高內聚力**：相關的邏輯被集中在一個類別中。
* **降低耦合度**：職責被劃分開，修改一個類別不會輕易影響到其他類別。
* **提高程式碼複用性**：每個類別職責單一，更容易在其他地方重複使用。

在範例 `SRPExample.cs` 中，我們將新增訂單的流程拆分為三個各司其職的類別：
* `OrderProcessor`：專門處理訂單的商業邏輯。
* `OrderRepository`：專門負責將訂單存入資料庫。
* `OrderNotifier`：專門負責通知客戶。

如此一來，呼叫端 `OrderService` 只需關心流程本身，而不需要知道每個步驟的實作細節。 這就是「展示清楚你的意圖」，讓每個類別的職責都非常單一。

---

## O－開放封閉原則 (OCP)

**軟體實體（類別、模組、函式等）應該對「擴充」開放，對「修改」封閉。**

面對新的需求，我們應該透過增加新的程式碼來完成，而不是去修改已經存在的程式碼。這就像組裝電腦，主機板上會預留很多擴充插槽（擴充點），當你需要新功能（如加裝顯示卡）時，是直接插入新的模組，而不是拆開主機板來修改它。

在 `OCPExample.cs` 範例中，`AreaService` 的 `GetArea` 方法依賴於 `IShape` 介面，而不是任何具體的形狀類別。 這個 `IShape` 介面就是我們的「擴充點」。當未來需要計算新的形狀（例如三角形）時，我們只需要新增一個實作 `IShape` 介面的 `Triangle` 類別即可，完全不需要修改 `AreaService` 的任何程式碼。

---

## L－里氏替換原則 (LSP)

**子類別必須能夠完全替換其父類別，而不會產生任何錯誤或異常。**

繼承的用意在於擴充父類別的行為，而非改變它。如果一個子類別的行為不符合父類別的預期，那麼它就違反了 LSP。一個經典的例子是「鳥類與企鵝」：如果 `Bird` 父類別有一個 `Fly()` 方法，那麼繼承它的 `Penguin` 子類別就會很尷尬，因為企鵝不會飛。

好的繼承應該基於「行為」，並滿足以下條件：
1.  **先驗條件不可強化**：子類別方法接受的參數條件，不應比父類別更嚴格。
2.  **後驗條件不可弱化**：子類別方法回傳的結果，不應比父類別的承諾更少。
3.  **不變條件必須維持**：父類別的行為在子類別中必須保持一致。

在範例 `LSPExample.cs` 中，我們不把 `Fly()` 方法放在 `Bird` 基底類別中，而是定義了一個 `IFlyable` 介面。 只有會飛的鳥（如 `Sparrow`）才去實作這個介面，而 `Penguin` 則不需要。 這樣，無論是 `Sparrow` 還是 `Penguin`，都可以被當作 `Bird` 來使用，而不會產生「企鵝被要求飛行」的矛盾情況。

---

## I－介面隔離原則 (ISP)

**不應該強迫使用者依賴它們未使用的方法。介面應該精簡、職責單一。**

如果一個介面定義了太多的方法（肥介面），會強迫實作它的類別去處理一些根本用不到的功能，這會導致產生許多空實作或拋出例外，造成程式碼的冗餘與誤導。

`ISPExample.cs` 中，我們將動物的能力拆分成 `IRun`、`IFly`、`ISwim` 三個小而美的介面。 `IspPenguin` 類別只需要跑步和游泳，所以它只需要實作 `IRun` 和 `ISwim` 即可，完全不必理會 `IFly` 介面。

這個原則在設計資料庫操作時也很有用。我們可以將 CRUD（Create, Read, Update, Delete）拆分成不同的介面，類別根據自身需求去實作對應的操作介面，避免實作不必要的功能。

---

## D－依賴反轉原則 (DIP)

**高階模組不應依賴於低階模組，兩者都應依賴於「抽象」。同時，抽象不應依賴於細節，細節應依賴於抽象。**

這聽起來很繞口，但核心思想是「解開耦合」。高階模組（如業務邏輯）不應該直接依賴低階模組（如資料庫存取、日誌記錄）。相反地，它們都應該依賴一個共同的「介面（抽象）」。

這通常透過**依賴注入 (Dependency Injection, DI)** 來實現。高階模組不再自己建立它需要的物件，而是由外部（通常是 DI 容器）將實作好的物件「注入」進來。

`DIPExample.cs` 的 `ReportService`（高階模組）在建構時需要一個 `IPrinter`（抽象）。它不在乎實際被注入的是在主控台列印的 `ConsolePrinter`（低階模組）還是其他印表機。只要符合 `IPrinter` 介面的物件，`ReportService` 都能正常工作，這大大提升了程式的彈性與可測試性。

---

## 迪米特法則 / 最小知識原則 (LKP)

**一個物件應該對其他物件有最少的了解，也就是「只和你的直接朋友溝通，不和陌生人說話」。**

這意味著在一個方法內部，我們應該只呼叫：
* 該物件自身的方法。
* 傳入參數物件的方法。
* 在方法內部建立的物件的方法。
* 直接依賴的成員物件的方法。

避免出現 `a.getB().getC().doSomething()` 這樣的長鏈式呼叫，因為這代表 `a` 物件知道了太多關於 `B` 和 `C` 的內部結構，形成了緊密的耦合。

`LKPExample.cs` 中的 `MessageController` 只與它的直接朋友 `MessageService` 溝通來取得訊息。 它並不知道、也不關心 `MessageService` 是如何從 `MessageProvider` 取得訊息的。 透過 `MessageService` 這個中介者，成功地降低了 `MessageController` 與 `MessageProvider` 之間的耦合。
